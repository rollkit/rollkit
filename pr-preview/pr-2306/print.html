<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rollkit Specifications</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="specs/template.html"><strong aria-hidden="true">1.</strong> Template</a></li><li class="chapter-item expanded "><a href="specs/rollkit-dependency-graph.html"><strong aria-hidden="true">2.</strong> Dependency Graph</a></li><li class="chapter-item expanded "><a href="specs/block-manager.html"><strong aria-hidden="true">3.</strong> Block Manager</a></li><li class="chapter-item expanded "><a href="specs/block-validity.html"><strong aria-hidden="true">4.</strong> Block Validity</a></li><li class="chapter-item expanded "><a href="specs/da.html"><strong aria-hidden="true">5.</strong> DA</a></li><li class="chapter-item expanded "><a href="specs/full_node.html"><strong aria-hidden="true">6.</strong> Full Node</a></li><li class="chapter-item expanded "><a href="specs/header-sync.html"><strong aria-hidden="true">7.</strong> Header Sync</a></li><li class="chapter-item expanded "><a href="../lazy-adr/adr-014-header-and-data-separation.html"><strong aria-hidden="true">8.</strong> Header and Data Separation ADR</a></li><li class="chapter-item expanded "><a href="../lazy-adr/adr-015-rollkit-minimal-header.html"><strong aria-hidden="true">9.</strong> Rollkit Minimal Header</a></li><li class="chapter-item expanded "><a href="specs/p2p.html"><strong aria-hidden="true">10.</strong> P2P</a></li><li class="chapter-item expanded "><a href="specs/store.html"><strong aria-hidden="true">11.</strong> Store</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rollkit Specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rollkit/rollkit" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p>Welcome to the Rollkit Specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocolcomponent-name"><a class="header" href="#protocolcomponent-name">Protocol/Component Name</a></h1>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>Provide a concise description of the purpose of the component for which the
specification is written, along with its contribution to the rollkit or
other relevant parts of the system. Make sure to include proper references to
the relevant sections.</p>
<h2 id="protocolcomponent-description"><a class="header" href="#protocolcomponent-description">Protocol/Component Description</a></h2>
<p>Offer a comprehensive explanation of the protocol, covering aspects such as data
flow, communication mechanisms, and any other details necessary for
understanding the inner workings of this component.</p>
<h2 id="message-structurecommunication-format"><a class="header" href="#message-structurecommunication-format">Message Structure/Communication Format</a></h2>
<p>If this particular component is expected to communicate over the network,
outline the structure of the message protocol, including details such as field
interpretation, message format, and any other relevant information.</p>
<h2 id="assumptions-and-considerations"><a class="header" href="#assumptions-and-considerations">Assumptions and Considerations</a></h2>
<p>If there are any assumptions required for the component's correct operation,
performance, security, or other expected features, outline them here.
Additionally, provide any relevant considerations related to security or other
concerns.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Include a link to the location where the implementation of this protocol can be
found. Note that specific implementation details should be documented in the
rollkit repository rather than in the specification document.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>List any references used or cited in the document.</p>
<h2 id="general-tips"><a class="header" href="#general-tips">General Tips</a></h2>
<h3 id="how-to-use-a-mermaid-diagram-that-you-can-display-in-a-markdown"><a class="header" href="#how-to-use-a-mermaid-diagram-that-you-can-display-in-a-markdown">How to use a mermaid diagram that you can display in a markdown</a></h3>
<pre><code class="language-mermaid">
sequenceDiagram
    title Example
    participant A
    participant B
    A-&gt;&gt;B: Example
    B-&gt;&gt;A: Example

</code></pre>
<pre><code class="language-mermaid">
graph LR
   A[Example] --&gt; B[Example]
   B --&gt; C[Example]
   C --&gt; A

</code></pre>
<pre><code class="language-mermaid">
gantt
   title Example
   dateFormat  YYYY-MM-DD
   section Example
   A :done,    des1, 2014-01-06,2014-01-08
   B :done,    des2, 2014-01-06,2014-01-08
   C :done,    des3, 2014-01-06,2014-01-08

</code></pre>
<h3 id="grammar-and-spelling-check"><a class="header" href="#grammar-and-spelling-check">Grammar and spelling check</a></h3>
<p>The recommendation is to use your favorite spellchecker extension in your IDE like <a href="https://www.grammarly.com/">grammarly</a>, to make sure that the document is free of spelling and grammar errors.</p>
<h3 id="use-of-links"><a class="header" href="#use-of-links">Use of links</a></h3>
<p>If you want to use links use proper syntax. This goes for both internal and external links like <a href="specs/../README.html">documentation</a> or <a href="https://github.com/celestiaorg/go-header">external links</a></p>
<p>At the bottom of the document in <a href="specs/template.html#references">Reference</a>, you can add the following footnotes that will be visible in the markdown document:</p>
<p>[1] <a href="https://www.grammarly.com/">Grammarly</a></p>
<p>[2] <a href="specs/../README.html">Documentation</a></p>
<p>[3] <a href="https://github.com/celestiaorg/go-header">external links</a></p>
<p>Then at the bottom add the actual links that will not be visible in the markdown document:</p>
<h3 id="use-of-tables"><a class="header" href="#use-of-tables">Use of tables</a></h3>
<p>If you are describing variables, components or other things in a structured list that can be described in a table use the following syntax:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>type</code></td><td>Description</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rollkit-dependency-graph"><a class="header" href="#rollkit-dependency-graph">Rollkit Dependency Graph</a></h1>
<p><img src="specs/./dependency-graph.drawio.svg" alt="Dependency Graph" /></p>
<p>We use the following color coding in this Graph:</p>
<ul>
<li>No Colour: Work not yet started</li>
<li>Yellow Box: Work in progress</li>
<li>Green Box: Work completed or at least unblocking the next dependency</li>
<li>Red Border: Work needs to happen in cooperation with another team</li>
</ul>
<p>If the EPICs are not linked to the box yet, it means that this box has currently no priority or is still in the ideation phase or the dependency is unclear.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-manager"><a class="header" href="#block-manager">Block Manager</a></h1>
<h2 id="abstract-1"><a class="header" href="#abstract-1">Abstract</a></h2>
<p>The block manager is a key component of full nodes and is responsible for block production or block syncing depending on the node type: sequencer or non-sequencer. Block syncing in this context includes retrieving the published blocks from the network (P2P network or DA network), validating them to raise fraud proofs upon validation failure, updating the state, and storing the validated blocks. A full node invokes multiple block manager functionalities in parallel, such as:</p>
<ul>
<li>Block Production (only for sequencer full nodes)</li>
<li>Block Publication to DA network</li>
<li>Block Retrieval from DA network</li>
<li>Block Sync Service</li>
<li>Block Publication to P2P network</li>
<li>Block Retrieval from P2P network</li>
<li>State Update after Block Retrieval</li>
</ul>
<pre><code class="language-mermaid">sequenceDiagram
    title Overview of Block Manager

    participant User
    participant Sequencer
    participant Full Node 1
    participant Full Node 2
    participant DA Layer

    User-&gt;&gt;Sequencer: Send Tx
    Sequencer-&gt;&gt;Sequencer: Generate Block
    Sequencer-&gt;&gt;DA Layer: Publish Block

    Sequencer-&gt;&gt;Full Node 1: Gossip Block
    Sequencer-&gt;&gt;Full Node 2: Gossip Block
    Full Node 1-&gt;&gt;Full Node 1: Verify Block
    Full Node 1-&gt;&gt;Full Node 2: Gossip Block
    Full Node 1-&gt;&gt;Full Node 1: Mark Block Soft Confirmed

    Full Node 2-&gt;&gt;Full Node 2: Verify Block
    Full Node 2-&gt;&gt;Full Node 2: Mark Block Soft Confirmed

    DA Layer-&gt;&gt;Full Node 1: Retrieve Block
    Full Node 1-&gt;&gt;Full Node 1: Mark Block DA Included

    DA Layer-&gt;&gt;Full Node 2: Retrieve Block
    Full Node 2-&gt;&gt;Full Node 2: Mark Block DA Included
</code></pre>
<h2 id="protocolcomponent-description-1"><a class="header" href="#protocolcomponent-description-1">Protocol/Component Description</a></h2>
<p>The block manager is initialized using several parameters as defined below:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Name</strong></th><th><strong>Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody>
<tr><td>signing key</td><td>crypto.PrivKey</td><td>used for signing a block after it is created</td></tr>
<tr><td>config</td><td>config.BlockManagerConfig</td><td>block manager configurations (see config options below)</td></tr>
<tr><td>genesis</td><td>*cmtypes.GenesisDoc</td><td>initialize the block manager with genesis state (genesis configuration defined in <code>config/genesis.json</code> file under the app directory)</td></tr>
<tr><td>store</td><td>store.Store</td><td>local datastore for storing rollup blocks and states (default local store path is <code>$db_dir/rollkit</code> and <code>db_dir</code> specified in the <code>config.yaml</code> file under the app directory)</td></tr>
<tr><td>mempool, proxyapp, eventbus</td><td>mempool.Mempool, proxy.AppConnConsensus, *cmtypes.EventBus</td><td>for initializing the executor (state transition function). mempool is also used in the manager to check for availability of transactions for lazy block production</td></tr>
<tr><td>dalc</td><td>da.DAClient</td><td>the data availability light client used to submit and retrieve blocks to DA network</td></tr>
<tr><td>blockstore</td><td>*goheaderstore.Store[*types.Block]</td><td>to retrieve blocks gossiped over the P2P network</td></tr>
</tbody></table>
</div>
<p>Block manager configuration options:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>BlockTime</td><td>time.Duration</td><td>time interval used for block production and block retrieval from block store (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L36"><code>defaultBlockTime</code></a>)</td></tr>
<tr><td>DABlockTime</td><td>time.Duration</td><td>time interval used for both block publication to DA network and block retrieval from DA network (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L33"><code>defaultDABlockTime</code></a>)</td></tr>
<tr><td>DAStartHeight</td><td>uint64</td><td>block retrieval from DA network starts from this height</td></tr>
<tr><td>LazyBlockInterval</td><td>time.Duration</td><td>time interval used for block production in lazy aggregator mode even when there are no transactions (<a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L39"><code>defaultLazyBlockTime</code></a>)</td></tr>
<tr><td>LazyMode</td><td>bool</td><td>when set to true, enables lazy aggregation mode which produces blocks only when transactions are available or at LazyBlockInterval intervals</td></tr>
</tbody></table>
</div>
<h3 id="block-production"><a class="header" href="#block-production">Block Production</a></h3>
<p>When the full node is operating as a sequencer (aka aggregator), the block manager runs the block production logic. There are two modes of block production, which can be specified in the block manager configurations: <code>normal</code> and <code>lazy</code>.</p>
<p>In <code>normal</code> mode, the block manager runs a timer, which is set to the <code>BlockTime</code> configuration parameter, and continuously produces blocks at <code>BlockTime</code> intervals.</p>
<p>In <code>lazy</code> mode, the block manager implements a dual timer mechanism:</p>
<ol>
<li>A <code>blockTimer</code> that triggers block production at regular intervals when transactions are available</li>
<li>A <code>lazyTimer</code> that ensures blocks are produced at <code>LazyBlockInterval</code> intervals even during periods of inactivity</li>
</ol>
<p>The block manager starts building a block when any transaction becomes available in the mempool via a notification channel (<code>txNotifyCh</code>). When the <code>Reaper</code> detects new transactions, it calls <code>Manager.NotifyNewTransactions()</code>, which performs a non-blocking signal on this channel. The block manager also produces empty blocks at regular intervals to maintain consistency with the DA layer, ensuring a 1:1 mapping between DA layer blocks and execution layer blocks.</p>
<h4 id="building-the-block"><a class="header" href="#building-the-block">Building the Block</a></h4>
<p>The block manager of the sequencer nodes performs the following steps to produce a block:</p>
<ul>
<li>Call <code>CreateBlock</code> using executor</li>
<li>Sign the block using <code>signing key</code> to generate commitment</li>
<li>Call <code>ApplyBlock</code> using executor to generate an updated state</li>
<li>Save the block, validators, and updated state to local store</li>
<li>Add the newly generated block to <code>pendingBlocks</code> queue</li>
<li>Publish the newly generated block to channels to notify other components of the sequencer node (such as block and header gossip)</li>
</ul>
<h3 id="block-publication-to-da-network"><a class="header" href="#block-publication-to-da-network">Block Publication to DA Network</a></h3>
<p>The block manager of the sequencer full nodes regularly publishes the produced blocks (that are pending in the <code>pendingBlocks</code> queue) to the DA network using the <code>DABlockTime</code> configuration parameter defined in the block manager config. In the event of failure to publish the block to the DA network, the manager will perform <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L50"><code>maxSubmitAttempts</code></a> attempts and an exponential backoff interval between the attempts. The exponential backoff interval starts off at <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go#L59"><code>initialBackoff</code></a> and it doubles in the next attempt and capped at <code>DABlockTime</code>. A successful publish event leads to the emptying of <code>pendingBlocks</code> queue and a failure event leads to proper error reporting without emptying of <code>pendingBlocks</code> queue.</p>
<h3 id="block-retrieval-from-da-network"><a class="header" href="#block-retrieval-from-da-network">Block Retrieval from DA Network</a></h3>
<p>The block manager of the full nodes regularly pulls blocks from the DA network at <code>DABlockTime</code> intervals and starts off with a DA height read from the last state stored in the local store or <code>DAStartHeight</code> configuration parameter, whichever is the latest. The block manager also actively maintains and increments the <code>daHeight</code> counter after every DA pull. The pull happens by making the <code>RetrieveBlocks(daHeight)</code> request using the Data Availability Light Client (DALC) retriever, which can return either <code>Success</code>, <code>NotFound</code>, or <code>Error</code>. In the event of an error, a retry logic kicks in after a delay of 100 milliseconds delay between every retry and after 10 retries, an error is logged and the <code>daHeight</code> counter is not incremented, which basically results in the intentional stalling of the block retrieval logic. In the block <code>NotFound</code> scenario, there is no error as it is acceptable to have no rollup block at every DA height. The retrieval successfully increments the <code>daHeight</code> counter in this case. Finally, for the <code>Success</code> scenario, first, blocks that are successfully retrieved are marked as DA included and are sent to be applied (or state update). A successful state update triggers fresh DA and block store pulls without respecting the <code>DABlockTime</code> and <code>BlockTime</code> intervals. For more details on DA integration, see the <a href="specs/./da.html">Data Availability specification</a>.</p>
<h4 id="out-of-order-rollup-blocks-on-da"><a class="header" href="#out-of-order-rollup-blocks-on-da">Out-of-Order Rollup Blocks on DA</a></h4>
<p>Rollkit should support blocks arriving out-of-order on DA, like so:
<img src="specs/./out-of-order-blocks.png" alt="out-of-order blocks" /></p>
<h4 id="termination-condition"><a class="header" href="#termination-condition">Termination Condition</a></h4>
<p>If the sequencer double-signs two blocks at the same height, evidence of the fault should be posted to DA. Rollkit full nodes should process the longest valid chain up to the height of the fault evidence, and terminate. See diagram:
<img src="specs/./termination.png" alt="termination conidition" /></p>
<h3 id="block-sync-service"><a class="header" href="#block-sync-service">Block Sync Service</a></h3>
<p>The block sync service is created during full node initialization. After that, during the block manager's initialization, a pointer to the block store inside the block sync service is passed to it. Blocks created in the block manager are then passed to the <code>BlockCh</code> channel and then sent to the <a href="https://github.com/celestiaorg/go-header">go-header</a> service to be gossiped blocks over the P2P network.</p>
<h3 id="block-publication-to-p2p-network"><a class="header" href="#block-publication-to-p2p-network">Block Publication to P2P network</a></h3>
<p>Blocks created by the sequencer that are ready to be published to the P2P network are sent to the <code>BlockCh</code> channel in Block Manager inside <code>publishLoop</code>.
The <code>blockPublishLoop</code> in the full node continuously listens for new blocks from the <code>BlockCh</code> channel and when a new block is received, it is written to the block store and broadcasted to the network using the block sync service.</p>
<p>Among non-sequencer full nodes, all the block gossiping is handled by the block sync service, and they do not need to publish blocks to the P2P network using any of the block manager components.</p>
<h3 id="block-retrieval-from-p2p-network"><a class="header" href="#block-retrieval-from-p2p-network">Block Retrieval from P2P network</a></h3>
<p>For non-sequencer full nodes, blocks gossiped through the P2P network are retrieved from the <code>Block Store</code> in <code>BlockStoreRetrieveLoop</code> in Block Manager.<br />
Starting off with a block store height of zero, for every <code>blockTime</code> unit of time, a signal is sent to the <code>blockStoreCh</code> channel in the block manager and when this signal is received, the <code>BlockStoreRetrieveLoop</code> retrieves blocks from the block store.<br />
It keeps track of the last retrieved block's height and every time the current block store's height is greater than the last retrieved block's height, it retrieves all blocks from the block store that are between these two heights.<br />
For each retrieved block, it sends a new block event to the <code>blockInCh</code> channel which is the same channel in which blocks retrieved from the DA layer are sent.</p>
<p>This block is marked as soft confirmed by the validating full node until the same block data and the corresponding header is seen on the DA layer, then it is marked DA-included.</p>
<h4 id="about-soft-confirmations-and-da-inclusions"><a class="header" href="#about-soft-confirmations-and-da-inclusions">About Soft Confirmations and DA Inclusions</a></h4>
<p>The block manager retrieves blocks from both the P2P network and the underlying DA network because the blocks are available in the P2P network faster and DA retrieval is slower (e.g., 1 second vs 6 seconds).<br />
The blocks retrieved from the P2P network are only marked as soft confirmed until the DA retrieval succeeds on those blocks and they are marked DA-included.<br />
DA-included blocks are considered to have a higher level of finality.</p>
<p><strong>DAIncluderLoop</strong>:<br />
A new loop, <code>DAIncluderLoop</code>, is responsible for advancing the <code>DAIncludedHeight</code> by checking if blocks after the current height have both their header and data marked as DA-included in the caches.<br />
If either the header or data is missing, the loop stops advancing.<br />
This ensures that only blocks with both header and data present are considered DA-included.</p>
<h3 id="state-update-after-block-retrieval"><a class="header" href="#state-update-after-block-retrieval">State Update after Block Retrieval</a></h3>
<p>The block manager stores and applies the block to update its state every time a new block is retrieved either via the P2P or DA network. State update involves:</p>
<ul>
<li><code>ApplyBlock</code> using executor: validates the block, executes the block (applies the transactions), captures the validator updates, and creates an updated state.</li>
<li><code>Commit</code> using executor: commit the execution and changes, update mempool, and publish events</li>
<li>Store the block, the validators, and the updated state.</li>
</ul>
<h2 id="message-structurecommunication-format-1"><a class="header" href="#message-structurecommunication-format-1">Message Structure/Communication Format</a></h2>
<p>The communication between the block manager and executor:</p>
<ul>
<li><code>InitChain</code>: initializes the chain state with the given genesis time, initial height, and chain ID using <code>InitChainSync</code> on the executor to obtain initial <code>appHash</code> and initialize the state.</li>
<li><code>CreateBlock</code>: prepare a block by polling transactions from mempool.</li>
<li><code>ApplyBlock</code>: validate the block, execute the block (apply transactions), validator updates, create and return updated state.</li>
<li><code>SetFinal</code>: sets the block as final when it's corresponding header and data are seen on the dA layer.</li>
</ul>
<h2 id="assumptions-and-considerations-1"><a class="header" href="#assumptions-and-considerations-1">Assumptions and Considerations</a></h2>
<ul>
<li>The block manager loads the initial state from the local store and uses genesis if not found in the local store, when the node (re)starts.</li>
<li>The default mode for sequencer nodes is normal (not lazy).</li>
<li>The sequencer can produce empty blocks.</li>
<li>In lazy aggregation mode, the block manager maintains consistency with the DA layer by producing empty blocks at regular intervals, ensuring a 1:1 mapping between DA layer blocks and execution layer blocks.</li>
<li>The lazy aggregation mechanism uses a dual timer approach:
<ul>
<li>A <code>blockTimer</code> that triggers block production when transactions are available</li>
<li>A <code>lazyTimer</code> that ensures blocks are produced even during periods of inactivity</li>
</ul>
</li>
<li>Empty batches are handled differently in lazy mode - instead of discarding them, they are returned with the <code>ErrNoBatch</code> error, allowing the caller to create empty blocks with proper timestamps.</li>
<li>Transaction notifications from the <code>Reaper</code> to the <code>Manager</code> are handled via a non-blocking notification channel (<code>txNotifyCh</code>) to prevent backpressure.</li>
<li>The block manager uses persistent storage (disk) when the <code>root_dir</code> and <code>db_path</code> configuration parameters are specified in <code>config.yaml</code> file under the app directory. If these configuration parameters are not specified, the in-memory storage is used, which will not be persistent if the node stops.</li>
<li>The block manager does not re-apply the block again (in other words, create a new updated state and persist it) when a block was initially applied using P2P block sync, but later was DA included during DA retrieval. The block is only marked DA included in this case.</li>
<li>The data sync store is created by prefixing <code>dataSync</code> on the main data store.</li>
<li>The genesis <code>ChainID</code> is used to create the <code>PubSubTopID</code> in go-header with the string <code>-block</code> appended to it. This append is because the full node also has a P2P header sync running with a different P2P network. Refer to <a href="https://github.com/celestiaorg/go-header">go-header</a> specs for more details.</li>
<li>Block sync over the P2P network works only when a full node is connected to the P2P network by specifying the initial seeds to connect to via <code>P2PConfig.Seeds</code> configuration parameter when starting the full node.</li>
<li>Node's context is passed down to all the components of the P2P block sync to control shutting down the service either abruptly (in case of failure) or gracefully (during successful scenarios).</li>
<li>The block manager supports the separation of header and data structures in Rollkit. This allows for expanding the sequencing scheme beyond single sequencing and enables the use of a decentralized sequencer mode. For detailed information on this architecture, see the <a href="specs/../../lazy-adr/adr-014-header-and-data-separation.html">Header and Data Separation ADR</a>.</li>
<li>The block manager processes blocks with a minimal header format, which is designed to eliminate dependency on CometBFT's header format and can be used to produce an execution layer tailored header if needed. For details on this header structure, see the <a href="specs/../../lazy-adr/adr-015-rollkit-minimal-header.html">Rollkit Minimal Header</a> specification.</li>
</ul>
<h2 id="implementation-1"><a class="header" href="#implementation-1">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">block-manager</a></p>
<p>See <a href="https://rollkit.dev/guides/full-node">tutorial</a> for running a multi-node network with both sequencer and non-sequencer full nodes.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<p>[1] <a href="https://github.com/celestiaorg/go-header">Go Header</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Block Sync</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[5] <a href="https://rollkit.dev/guides/full-node">Tutorial</a></p>
<p>[6] <a href="specs/../../lazy-adr/adr-014-header-and-data-separation.html">Header and Data Separation ADR</a></p>
<p>[7] <a href="specs/../../lazy-adr/adr-015-rollkit-minimal-header.html">Rollkit Minimal Header</a></p>
<p>[8] <a href="specs/./da.html">Data Availability</a></p>
<p>[9] <a href="specs/../../lazy-adr/adr-021-lazy-aggregation.html">Lazy Aggregation with DA Layer Consistency ADR</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-and-header-validity"><a class="header" href="#block-and-header-validity">Block and Header Validity</a></h1>
<h2 id="abstract-2"><a class="header" href="#abstract-2">Abstract</a></h2>
<p>Like all blockchains, rollups are defined as the chain of <strong>valid</strong> blocks from the genesis, to the head. Thus, the block and header validity rules define the chain.</p>
<p>Verifying a block/header is done in 3 parts:</p>
<ol>
<li>
<p>Verify correct serialization according to the protobuf spec</p>
</li>
<li>
<p>Perform basic validation of the types</p>
</li>
<li>
<p>Perform verification of the new block against the previously accepted block</p>
</li>
</ol>
<h2 id="basic-validation"><a class="header" href="#basic-validation">Basic Validation</a></h2>
<p>Each type contains a <code>.ValidateBasic()</code> method, which verifies that certain basic invariants hold. The <code>ValidateBasic()</code> calls are nested, starting from the <code>Block</code> struct, all the way down to each subfield.</p>
<p>The nested basic validation, and validation checks, are called as follows:</p>
<pre><code class="language-go">Block.ValidateBasic()
  // Make sure the block's SignedHeader passes basic validation
  SignedHeader.ValidateBasic()
    // Make sure the SignedHeader's Header passes basic validation
    Header.ValidateBasic()
	  verify ProposerAddress not nil
	// Make sure the SignedHeader's signature passes basic validation
	Signature.ValidateBasic()
	  // Ensure that someone signed the block
	  verify len(c.Signatures) not 0
	If sh.Validators is nil, or len(sh.Validators.Validators) is 0, assume based rollup, pass validation, and skip all remaining checks.
	Validators.ValidateBasic()
	  // github.com/rollkit/cometbft/blob/main/types/validator.go#L37
	  verify sh.Validators is not nil, and len(sh.Validators.Validators) != 0
	  // apply basic validation to all Validators
	  for each validator:
	    validator.ValidateBasic()
		  validate not nil
		  validator.PubKey not nil
		  validator.Address == correct size
	  // apply ValidateBasic to the proposer field:
	  sh.Validators.Proposer.ValidateBasic()
		validate not nil
		validator.PubKey not nil
		validator.Address == correct size
    Assert that SignedHeader.Validators.Hash() == SignedHeader.AggregatorsHash
	Verify SignedHeader.Signature
  Data.ValidateBasic() // always passes
  // make sure the SignedHeader's DataHash is equal to the hash of the actual data in the block.
  Data.Hash() == SignedHeader.DataHash
</code></pre>
<h2 id="verification-against-previous-block"><a class="header" href="#verification-against-previous-block">Verification Against Previous Block</a></h2>
<pre><code class="language-go">// code does not match spec: see https://github.com/rollkit/rollkit/issues/1277
Block.Verify()
  SignedHeader.Verify(untrustH *SignedHeader)
    // basic validation removed in #1231, because go-header already validates it
    //untrustH.ValidateBasic()
	Header.Verify(untrustH *SignedHeader)
	  if untrustH.Height == h.Height + 1, then apply the following check:
	    untrstH.AggregatorsHash[:], h.NextAggregatorsHash[:]
	if untrustH.Height &gt; h.Height + 1:
	  soft verification failure
	// We should know they're adjacent now,
	// verify the link to previous.
	untrustH.LastHeaderHash == h.Header.Hash()
	// Verify LastCommit hash
	untrustH.LastCommitHash == sh.Signature.GetCommitHash(...)

</code></pre>
<h2 id="block"><a class="header" href="#block"><a href="https://github.com/rollkit/rollkit/blob/main/types/block.go#L26">Block</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>SignedHeader</td><td>Header of the block, signed by proposer</td><td>(See SignedHeader)</td></tr>
<tr><td>Data</td><td>Transaction data of the block</td><td>Data.Hash == SignedHeader.DataHash</td></tr>
</tbody></table>
</div>
<h2 id="signedheader"><a class="header" href="#signedheader"><a href="https://github.com/rollkit/rollkit/blob/main/types/signed_header.go#L16">SignedHeader</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>Header</td><td>Valid header for the block</td><td><code>Header</code> passes <code>ValidateBasic()</code> and <code>Verify()</code></td></tr>
<tr><td>Signature</td><td>1 valid signature from the single sequencer</td><td><code>Signature</code> passes <code>ValidateBasic()</code>, with additional checks in <code>SignedHeader.ValidateBasic()</code></td></tr>
<tr><td>Validators</td><td>Array of Aggregators, must have length exactly 1.</td><td><code>Validators</code> passes <code>ValidateBasic()</code></td></tr>
</tbody></table>
</div>
<h2 id="header"><a class="header" href="#header"><a href="https://github.com/rollkit/rollkit/blob/main/types/header.go#L39">Header</a></a></h2>
<p><em><strong>Note</strong></em>: The <code>AggregatorsHash</code> and <code>NextAggregatorsHash</code> fields have been removed. Rollkit vA should ignore all Valset updates from the ABCI app, and always enforce that the proposer is the single sequencer set as the 1 validator in the genesis block.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td><strong>BaseHeader</strong> .</td><td></td><td></td></tr>
<tr><td>Height</td><td>Height of the previous accepted header, plus 1.</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>Time</td><td>Timestamp of the block</td><td>Not validated in Rollkit</td></tr>
<tr><td>ChainID</td><td>The hard-coded ChainID of the chain</td><td>Should be checked as soon as the header is received</td></tr>
<tr><td><strong>Header</strong> .</td><td></td><td></td></tr>
<tr><td>Version</td><td>unused</td><td></td></tr>
<tr><td>LastHeaderHash</td><td>The hash of the previous accepted block</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>LastCommitHash</td><td>The hash of the previous accepted block's commit</td><td>checked in the `Verify()`` step</td></tr>
<tr><td>DataHash</td><td>Correct hash of the block's Data field</td><td>checked in the `ValidateBasic()`` step</td></tr>
<tr><td>ConsensusHash</td><td>unused</td><td></td></tr>
<tr><td>AppHash</td><td>The correct state root after executing the block's transactions against the accepted state</td><td>checked during block execution</td></tr>
<tr><td>LastResultsHash</td><td>Correct results from executing transactions</td><td>checked during block execution</td></tr>
<tr><td>ProposerAddress</td><td>Address of the expected proposer</td><td>checked in the <code>Verify()</code> step</td></tr>
<tr><td>Signature</td><td>Signature of the expected proposer</td><td>signature verification occurs in the <code>ValidateBasic()</code> step</td></tr>
</tbody></table>
</div>
<h2 id="validatorset"><a class="header" href="#validatorset"><a href="https://github.com/cometbft/cometbft/blob/main/types/validator_set.go#L51">ValidatorSet</a></a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Field Name</strong></th><th><strong>Valid State</strong></th><th><strong>Validation</strong></th></tr></thead><tbody>
<tr><td>Validators</td><td>Array of validators, each must pass <code>Validator.ValidateBasic()</code></td><td><code>Validator.ValidateBasic()</code></td></tr>
<tr><td>Proposer</td><td>Must pass <code>Validator.ValidateBasic()</code></td><td><code>Validator.ValidateBasic()</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="da"><a class="header" href="#da">DA</a></h1>
<p>Rollkit provides a wrapper for <a href="https://github.com/rollkit/go-da">go-da</a>, a generic data availability interface for modular blockchains, called <code>DAClient</code> with wrapper functionalities like <code>SubmitBlocks</code> and <code>RetrieveBlocks</code> to help block manager interact with DA more easily.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p><code>DAClient</code> can connect via either gRPC or JSON-RPC transports using the <a href="https://github.com/rollkit/go-da">go-da</a> <a href="https://github.com/rollkit/go-da/tree/main/proxy/grpc">proxy/grpc</a> or <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">proxy/jsonrpc</a> implementations. The connection can be configured using the following cli flags:</p>
<ul>
<li><code>--rollkit.da_address</code>: url address of the DA service (default: &quot;grpc://localhost:26650&quot;)</li>
<li><code>--rollkit.da_auth_token</code>: authentication token of the DA service</li>
<li><code>--rollkit.da_namespace</code>: namespace to use when submitting blobs to the DA service</li>
</ul>
<p>Given a set of blocks to be submitted to DA by the block manager, the <code>SubmitBlocks</code> first encodes the blocks using protobuf (the encoded data are called blobs) and invokes the <code>Submit</code> method on the underlying DA implementation. On successful submission (<code>StatusSuccess</code>), the DA block height which included in the blocks is returned.</p>
<p>To make sure that the serialised blocks don't exceed the underlying DA's blob limits, it fetches the blob size limit by calling <code>Config</code> which returns the limit as <code>uint64</code> bytes, then includes serialised blocks until the limit is reached. If the limit is reached, it submits the partial set and returns the count of successfully submitted blocks as <code>SubmittedCount</code>. The caller should retry with the remaining blocks until all the blocks are submitted. If the first block itself is over the limit, it throws an error.</p>
<p>The <code>Submit</code> call may result in an error (<code>StatusError</code>) based on the underlying DA implementations on following scenarios:</p>
<ul>
<li>the total blobs size exceeds the underlying DA's limits (includes empty blobs)</li>
<li>the implementation specific failures, e.g., for <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">celestia-da-json-rpc</a>, invalid namespace, unable to create the commitment or proof, setting low gas price, etc, could return error.</li>
</ul>
<p>The <code>RetrieveBlocks</code> retrieves the blocks for a given DA height using <a href="https://github.com/rollkit/go-da">go-da</a> <code>GetIDs</code> and <code>Get</code> methods. If there are no blocks available for a given DA height, <code>StatusNotFound</code> is returned (which is not an error case). The retrieved blobs are converted back to blocks and returned on successful retrieval.</p>
<p>Both <code>SubmitBlocks</code> and <code>RetrieveBlocks</code> may be unsuccessful if the DA node and the DA blockchain that the DA implementation is using have failures. For example, failures such as, DA mempool is full, DA submit transaction is nonce clashing with other transaction from the DA submitter account, DA node is not synced, etc.</p>
<h2 id="implementation-2"><a class="header" href="#implementation-2">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/da/jsonrpc/client.go">da implementation</a></p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/go-da">go-da</a></p>
<p>[2] <a href="https://github.com/rollkit/go-da/tree/main/proxy/grpc">proxy/grpc</a></p>
<p>[3] <a href="https://github.com/rollkit/go-da/tree/main/proxy/jsonrpc">proxy/jsonrpc</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="full-node"><a class="header" href="#full-node">Full Node</a></h1>
<h2 id="abstract-3"><a class="header" href="#abstract-3">Abstract</a></h2>
<p>A Full Node is a top-level service that encapsulates different components of Rollkit and initializes/manages them.</p>
<h2 id="details-1"><a class="header" href="#details-1">Details</a></h2>
<h3 id="full-node-details"><a class="header" href="#full-node-details">Full Node Details</a></h3>
<p>A Full Node is initialized inside the Cosmos SDK start script along with the node configuration, a private key to use in the P2P client, a private key for signing blocks as a block proposer, a client creator, a genesis document, and a logger. It uses them to initialize the components described above. The components TxIndexer, BlockIndexer, and IndexerService exist to ensure cometBFT compatibility since they are needed for most of the RPC calls from the <code>SignClient</code> interface from cometBFT.</p>
<p>Note that unlike a light node which only syncs and stores block headers seen on the P2P layer, the full node also syncs and stores full blocks seen on both the P2P network and the DA layer. Full blocks contain all the transactions published as part of the block.</p>
<p>The Full Node mainly encapsulates and initializes/manages the following components:</p>
<h3 id="genesisdoc"><a class="header" href="#genesisdoc">genesisDoc</a></h3>
<p>The <a href="https://github.com/cometbft/cometbft/blob/main/spec/core/genesis.md">genesis</a> document contains information about the initial state of the chain, in particular its validator set.</p>
<h3 id="conf"><a class="header" href="#conf">conf</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/config/config.go">node configuration</a> contains all the necessary settings for the node to be initialized and function properly.</p>
<h3 id="p2p"><a class="header" href="#p2p">P2P</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">peer-to-peer client</a> is used to gossip transactions between full nodes in the network.</p>
<h3 id="store"><a class="header" href="#store">Store</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Store</a> is initialized with <code>DefaultStore</code>, an implementation of the <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go">store interface</a> which is used for storing and retrieving blocks, commits, and state. |</p>
<h3 id="blockmanager"><a class="header" href="#blockmanager">blockManager</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a> is responsible for managing the operations related to blocks such as creating and validating blocks.</p>
<h3 id="dalc"><a class="header" href="#dalc">dalc</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/core/da/da.go">Data Availability Layer Client</a> is used to interact with the data availability layer. It is initialized with the DA Layer and DA Config specified in the node configuration.</p>
<h3 id="hexservice"><a class="header" href="#hexservice">hExService</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Header Sync Service</a> is used for syncing block headers between nodes over P2P.</p>
<h3 id="bsyncservice"><a class="header" href="#bsyncservice">bSyncService</a></h3>
<p>The <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Block Sync Service</a> is used for syncing blocks between nodes over P2P.</p>
<h2 id="message-structurecommunication-format-2"><a class="header" href="#message-structurecommunication-format-2">Message Structure/Communication Format</a></h2>
<p>The Full Node communicates with other nodes in the network using the P2P client. It also communicates with the application using the ABCI proxy connections. The communication format is based on the P2P and ABCI protocols.</p>
<h2 id="assumptions-and-considerations-2"><a class="header" href="#assumptions-and-considerations-2">Assumptions and Considerations</a></h2>
<p>The Full Node assumes that the configuration, private keys, client creator, genesis document, and logger are correctly passed in by the Cosmos SDK. It also assumes that the P2P client, data availability layer client, block manager, and other services can be started and stopped without errors.</p>
<h2 id="implementation-3"><a class="header" href="#implementation-3">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">full node</a></p>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[2] <a href="https://github.com/cometbft/cometbft/blob/main/spec/core/genesis.md">Genesis Document</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/config/config.go">Node Configuration</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">Peer to Peer Client</a></p>
<p>[5] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Store</a></p>
<p>[6] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go">Store Interface</a></p>
<p>[7] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[8] <a href="https://github.com/rollkit/rollkit/blob/main/core/da/da.go">Data Availability Layer Client</a></p>
<p>[9] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Header Sync Service</a></p>
<p>[10] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Block Sync Service</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-sync"><a class="header" href="#header-sync">Header Sync</a></h1>
<h2 id="abstract-4"><a class="header" href="#abstract-4">Abstract</a></h2>
<p>The nodes in the P2P network sync headers using the header sync service that implements the <a href="https://github.com/celestiaorg/go-header">go-header</a> interface. The header sync service consists of several components as listed below.</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th></tr></thead><tbody>
<tr><td>store</td><td>a <code>headerEx</code> prefixed <a href="https://github.com/ipfs/go-datastore">datastore</a> where synced headers are stored</td></tr>
<tr><td>subscriber</td><td>a <a href="https://github.com/libp2p/go-libp2p">libp2p</a> node pubsub subscriber</td></tr>
<tr><td>P2P server</td><td>a server for handling header requests between peers in the P2P network</td></tr>
<tr><td>exchange</td><td>a client that enables sending in/out-bound header requests from/to the P2P network</td></tr>
<tr><td>syncer</td><td>a service for efficient synchronization for headers. When a P2P node falls behind and wants to catch up to the latest network head via P2P network, it can use the syncer.</td></tr>
</tbody></table>
</div>
<h2 id="details-2"><a class="header" href="#details-2">Details</a></h2>
<p>All three types of nodes (sequencer, full, and light) run the header sync service to maintain the canonical view of the chain (with respect to the P2P network).</p>
<p>The header sync service inherits the <code>ConnectionGater</code> from the node's P2P client which enables blocking and allowing peers as needed by specifying the <code>P2PConfig.BlockedPeers</code> and <code>P2PConfig.AllowedPeers</code>.</p>
<p><code>NodeConfig.BlockTime</code> is used to configure the syncer such that it can effectively decide the outdated headers while it receives headers from the P2P network.</p>
<p>Both header and block sync utilizes <a href="https://github.com/celestiaorg/go-header">go-header</a> library and runs two separate sync services, for the headers and blocks. This distinction is mainly to serve light nodes which do not store blocks, but only headers synced from the P2P network.</p>
<h3 id="consumption-of-header-sync"><a class="header" href="#consumption-of-header-sync">Consumption of Header Sync</a></h3>
<p>The sequencer node, upon successfully creating the block, publishes the signed block header to the P2P network using the header sync service. The full/light nodes run the header sync service in the background to receive and store the signed headers from the P2P network. Currently the full/light nodes do not consume the P2P synced headers, however they have future utilities in performing certain checks.</p>
<h2 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h2>
<ul>
<li>The header sync store is created by prefixing <code>headerSync</code> the main datastore.</li>
<li>The genesis <code>ChainID</code> is used to create the <code>PubsubTopicID</code> in <a href="https://github.com/celestiaorg/go-header">go-header</a>. For example, for ChainID <code>gm</code>, the pubsub topic id is <code>/gm/header-sub/v0.0.1</code>. Refer to go-header specs for further details.</li>
<li>The header store must be initialized with genesis header before starting the syncer service. The genesis header can be loaded by passing the genesis header hash via <code>NodeConfig.TrustedHash</code> configuration parameter or by querying the P2P network. This imposes a time constraint that full/light nodes have to wait for the sequencer to publish the genesis header to the P2P network before starting the header sync service.</li>
<li>The Header Sync works only when the node is connected to the P2P network by specifying the initial seeds to connect to via the <code>P2PConfig.Seeds</code> configuration parameter.</li>
<li>The node's context is passed down to all the components of the P2P header sync to control shutting down the service either abruptly (in case of failure) or gracefully (during successful scenarios).</li>
</ul>
<h2 id="implementation-4"><a class="header" href="#implementation-4">Implementation</a></h2>
<p>The header sync implementation can be found in <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">block/sync_service.go</a>. The full and light nodes create and start the header sync service under <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">full</a> and <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go">light</a>.</p>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/sync/sync_service.go">Header Sync</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go">Full Node</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/light.go">Light Node</a></p>
<p>[4] <a href="https://github.com/celestiaorg/go-header">go-header</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="header-and-data-separation-adr"><a class="header" href="#header-and-data-separation-adr">Header and Data Separation ADR</a></h1>
<h2 id="abstract-5"><a class="header" href="#abstract-5">Abstract</a></h2>
<p>The separation of header and data structures in Rollkit unlocks expanding the sequencing scheme beyond single sequencing and unlocks the use of a decentralized sequencer mode. This means that the creation of list of the transactions can be done by another network as well while nodes still produce headers after executing that list of transactions. This overall change is akin to the proposer-builder separation in the Ethereum protocol, where the Rollkit header producer acts as the proposer, and the sequencer, which produces a list of transactions, acts as the builder.</p>
<h3 id="before-separation"><a class="header" href="#before-separation">Before Separation</a></h3>
<pre><code class="language-mermaid">flowchart LR
    CS[Single Sequencer] --&gt;|Creates| B[Block]
    B --&gt;|Contains| SH1[SignedHeader]
    B --&gt;|Contains| D1[Data]

    class CS,B,SH1,D1 node
</code></pre>
<h3 id="after-separation"><a class="header" href="#after-separation">After Separation</a></h3>
<pre><code class="language-mermaid">flowchart LR
    HP[Header Producer] --&gt;|Creates| SH2[SignedHeader]
    SEQ[Sequencer] --&gt;|Creates| D2[Data]
    SH2 -.-&gt;|References via DataCommitment| D2

    class HP,SEQ,SH2,D2 node
</code></pre>
<h2 id="protocolcomponent-description-2"><a class="header" href="#protocolcomponent-description-2">Protocol/Component Description</a></h2>
<p>Before, Rollkit only supported the use of a single sequencer that was responsible for creating a list of transactions by reaping its mempool, executing them to produce a header, and putting them together in a block. Rollkit headers and data were encapsulated within a single block structure. The block struct looked like this:</p>
<pre><code class="language-go">// Block defines the structure of Rollkit block.
type Block struct {
	SignedHeader SignedHeader
	Data         Data
}
</code></pre>
<p>The separation of header and data into distinct structures allows them to be processed independently. The <code>SignedHeader</code> struct now focuses on the header information, while the <code>Data</code> struct handles transaction data separately. This separation is particularly beneficial in unlocking based sequencing, where users submit transactions directly to the Data Availability layer which acts as the entity responsible for creating the list of transactions.</p>
<pre><code class="language-mermaid">classDiagram
    class Block {
        SignedHeader
        Data
    }

    class SignedHeader {
        Header
        Signature
    }

    class Header {
        ParentHash
        Height
        Timestamp
        ChainID
        DataCommitment
        StateRoot
        ExtraData
    }

    class Data {
        Metadata
        Txs
    }

    Block *-- SignedHeader
    Block *-- Data
    SignedHeader *-- Header
</code></pre>
<p>This change also affects how full nodes sync. Previously, full nodes would apply the transactions from the <code>Block</code> struct and verify that the <code>header</code> in <code>SignedHeader</code> matched their locally produced header. Now, with the separation, full nodes obtain the transaction data separately (via the DA layer directly in based sequencer mode, or via p2p gossip/DA layer in single sequencer mode) and verify it against the header signed by the header producer once they have both components. If a full node receives the header/data via a p2p gossip layer, they should wait to see the same header/data on the DA layer before marking the corresponding block as finalized in their view.</p>
<p>This ensures that the data integrity and consistency are maintained across the network.</p>
<pre><code class="language-go">// SignedHeader struct consists of the header and a signature
type SignedHeader struct {
    Header // Rollkit Header
    Signature  Signature // Signature of the header producer
    ...
}

// Header struct focusing on header information
type Header struct {
    // Hash of the previous block header.
    ParentHash Hash
    // Height represents the block height (aka block number) of a given header
    Height uint64
    // Block creation timestamp
    Timestamp uint64
    // The Chain ID
    ChainID string
    // Pointer to location of associated block data aka transactions in the DA layer
    DataCommitment Hash
    // Commitment representing the state linked to the header
    StateRoot Hash
    // Arbitrary field for additional metadata
    ExtraData []byte
}

// Data defines Rollkit block data.
type Data struct {
	*Metadata // Defines metadata for Data struct to help with p2p gossiping.
	Txs Txs // List of transactions to be executed
}
</code></pre>
<p>The <code>publishBlock</code> method in <code>manager.go</code> now creates the header and data structures separately. This decoupling allows for the header to be submitted to the DA layer independently of the block data, which can be built by a separate network. This change supports the transition from a single sequencer mode to a decentralized sequencer mode, making the system more modular.</p>
<h2 id="message-structurecommunication-format-3"><a class="header" href="#message-structurecommunication-format-3">Message Structure/Communication Format</a></h2>
<h3 id="header-producer"><a class="header" href="#header-producer">Header Producer</a></h3>
<p>Before the separation: Only the entire <code>Block</code> struct composed of both header and data was submitted to the DA layer. The <code>Block</code> and <code>SignedHeader</code> were both gossipped over two separate p2p layers: gossipping <code>Block</code> to just full nodes and gossipping the <code>SignedHeader</code> to full nodes and future light nodes to join that will only sync headers (and proofs).</p>
<p>After the separation: The <code>SignedHeader</code> and <code>Data</code> are submitted separately to the DA layer. Note that the <code>SignedHeader</code> has a <code>Header</code> that is linked to the <code>Data</code> via a <code>DataCommitment</code> from the DA layer. <code>SignedHeader</code> and <code>Data</code> are both gossipped over two separate p2p layers: gossipping <code>Data</code> to just full nodes and gossipping the <code>SignedHeader</code> to full nodes and future light nodes to join that will only sync headers (and proofs).</p>
<p>In based sequencing mode, the header producer is equivalent to a full node.</p>
<h3 id="before-separation-1"><a class="header" href="#before-separation-1">Before Separation</a></h3>
<pre><code class="language-mermaid">flowchart LR

    CS1[Single Sequencer] --&gt;|Submits Block| DA1[DA Layer]
    CS1 --&gt;|Gossips Block| FN1[Full Nodes]
    CS1 --&gt;|Gossips SignedHeader| LN1[Light Nodes]

    class CS1,DA1,FN1,LN1 node
</code></pre>
<h3 id="after-separation---single-sequencer-mode"><a class="header" href="#after-separation---single-sequencer-mode">After Separation - Single Sequencer Mode</a></h3>
<pre><code class="language-mermaid">flowchart LR

    CS2[Single Sequencer] --&gt;|Submits Data| DA2[DA Layer]
    HP2[Header Producer] --&gt;|Submits SignedHeader| DA2

    CS2 --&gt;|Gossips Data| FN2[Full Nodes]
    HP2 --&gt;|Gossips SignedHeader| FN2
    HP2 --&gt;|Gossips SignedHeader| LN2[Light Nodes]

    class CS2,HP2,DA2,FN2,LN2 node
</code></pre>
<h3 id="after-separation---based-mode"><a class="header" href="#after-separation---based-mode">After Separation - Based Mode</a></h3>
<pre><code class="language-mermaid">flowchart LR

    Users --&gt;|Submit Txs| DA3[DA Layer]
    FN3[Full Node/Header Producer] --&gt;|Reads Data| DA3

    class Users,DA3,FN3,LN3 node
</code></pre>
<h3 id="syncing-full-node"><a class="header" href="#syncing-full-node">Syncing Full Node</a></h3>
<p>Before the separation: Full Nodes get the entire <code>Block</code> struct via p2p or the DA layer. They can choose to apply the block as soon as they get it via p2p OR just wait to see it on the DA layer. This depends on whether a full node opts in to the p2p layer or not. Gossipping the <code>SignedHeader</code> over p2p is primarily for light nodes to get the header.</p>
<p>After the separation: Full nodes get the <code>Data</code> struct and the <code>SignedHeader</code> struct separately over p2p and DA layers. In code, this refers to the <code>HeaderStore</code> and the <code>DataStore</code> in block manager. A Full node should wait for having both the <code>Data</code> struct and the corresponding <code>SignedHeader</code> to it before applying the block data to its associated state machine. This is so that the full node can verify that its locally produced header's state commitment after it applies the <code>Data</code> associated to a block is consistent with the <code>Header</code> inside the <code>SignedHeader</code> that is received from the header producer. The <code>Header</code> should contain a link to its associated Data via a <code>DataCommitment</code> that is a pointer to the location of the <code>Data</code> on the DA layer.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant FN as Full Node
    participant P2P as P2P Network
    participant DA as DA Layer
    participant SM as State Machine

    Note over FN,DA: After Separation - Sync Process

    P2P-&gt;&gt;FN: Receive Data
    P2P-&gt;&gt;FN: Receive SignedHeader
    FN-&gt;&gt;DA: Verify Data availability
    FN-&gt;&gt;DA: Verify SignedHeader availability
    FN-&gt;&gt;FN: Match Data with SignedHeader via DataCommitment
    FN-&gt;&gt;SM: Apply Data to state machine
    FN-&gt;&gt;FN: Verify locally produced header matches received Header
    FN-&gt;&gt;FN: Mark block as finalized
</code></pre>
<p>In a single sequencer mode, before, a full node marks a block finalized, it should verify that both the <code>SignedHeader</code> and <code>Data</code> associated to it were made available on the DA layer by checking it directly or verifying DA inclusion proofs.</p>
<p>In based sequencing mode, blocks can be instantly finalized since the <code>Data</code> is directly always derived from the DA layer and already exists there. There's no need for a <code>SignedHeader</code> to exist on the DA layer.</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant DA as DA Layer
    participant FN as Full Node
    participant SM as State Machine

    Note over DA,FN: Based Sequencing Mode

    DA-&gt;&gt;FN: Data already available
    FN-&gt;&gt;FN: Read Data from DA
    FN-&gt;&gt;FN: Execute transactions
    FN-&gt;&gt;FN: Produce Header
    FN-&gt;&gt;SM: Apply state changes
    FN-&gt;&gt;FN: Finalize Block
    Note right of FN: No need to submit SignedHeader to DA
</code></pre>
<h2 id="assumptions-and-considerations-3"><a class="header" href="#assumptions-and-considerations-3">Assumptions and Considerations</a></h2>
<ul>
<li>Considerations include ensuring that headers and data are correctly synchronized and validated to prevent inconsistencies.</li>
<li>Ensure that all components interacting with headers and data are updated to handle them as separate entities.</li>
<li>Security measures should be in place to prevent unauthorized access or tampering with headers and data during transmission and storage.</li>
<li>Performance optimizations may be necessary to handle the increased complexity of managing separate header and data structures, especially in high-throughput environments.</li>
<li>Testing and validation processes should be updated to account for the new structure and ensure that all components function correctly in both single and decentralized sequencer modes.</li>
</ul>
<h2 id="implementation-5"><a class="header" href="#implementation-5">Implementation</a></h2>
<p>The implementation of this separation can be found in the Rollkit repository, specifically in the changes made to the <code>manager.go</code> file. The <code>publishBlock</code> method illustrates the creation of separate header and data structures, and the associated logic for handling them independently. See <a href="https://github.com/rollkit/rollkit/pull/1789">Rollkit PR #1789</a></p>
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ul>
<li><a href="https://github.com/rollkit/rollkit/pull/1789">Rollkit PR #1789</a></li>
<li><a href="https://www.alchemy.com/overviews/proposer-builder-separation">Proposer-Builder Separation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rollkit-minimal-header"><a class="header" href="#rollkit-minimal-header">Rollkit Minimal Header</a></h1>
<h2 id="abstract-6"><a class="header" href="#abstract-6">Abstract</a></h2>
<p>This document specifies a minimal header format for Rollkit, designed to eliminate the dependency on CometBFT's header format. This new format can then be used to produce an execution layer tailored header if needed. For example, the new ABCI Execution layer can have an ABCI-specific header for IBC compatibility. This allows Rollkit to define its own header structure while maintaining backward compatibility where necessary.</p>
<h2 id="protocolcomponent-description-3"><a class="header" href="#protocolcomponent-description-3">Protocol/Component Description</a></h2>
<p>The Rollkit minimal header is a streamlined version of the traditional header, focusing on essential information required for block processing and state management for nodes. This header format is designed to be lightweight and efficient, facilitating faster processing and reduced overhead.</p>
<h3 id="rollkit-minimal-header-structure"><a class="header" href="#rollkit-minimal-header-structure">Rollkit Minimal Header Structure</a></h3>
<pre><code class="language-ascii">
             Rollkit Minimal Header          

 ParentHash           Hash of previous block

 Height               Block number          

 Timestamp            Creation time         

 ChainID              Chain identifier      

 DataCommitment       Pointer to block data 
                      on DA layer           

 StateRoot            State commitment      

 ExtraData            Additional metadata   
                      (e.g. sequencer info) 

</code></pre>
<h2 id="message-structurecommunication-format-4"><a class="header" href="#message-structurecommunication-format-4">Message Structure/Communication Format</a></h2>
<p>The header is defined in GoLang as follows:</p>
<pre><code class="language-go">// Header struct focusing on header information
type Header struct {
    // Hash of the previous block header.
    ParentHash Hash
    // Height represents the block height (aka block number) of a given header
    Height uint64
    // Block creation timestamp
    Timestamp uint64
    // The Chain ID
    ChainID string
    // Pointer to location of associated block data aka transactions in the DA layer
    DataCommitment []byte
    // Commitment representing the state linked to the header
    StateRoot Hash
    // Arbitrary field for additional metadata
    ExtraData []byte
}
</code></pre>
<p>In case the chain has a specific designated proposer or a proposer set, that information can be put in the <code>extraData</code> field. So in single sequencer mode, the <code>sequencerAddress</code> can live in <code>extraData</code>. For base sequencer mode, this information is not relevant.</p>
<p>This minimal Rollkit header can be transformed to be tailored to a specific execution layer as well by inserting additional information typically needed.</p>
<h3 id="evm-execution-client"><a class="header" href="#evm-execution-client">EVM execution client</a></h3>
<ul>
<li><code>transactionsRoot</code>: Merkle root of all transactions in the block. Can be constructed from unpacking the <code>DataCommitment</code> in Rollkit Header.</li>
<li><code>receiptsRoot</code>: Merkle root of all transaction receipts, which store the results of transaction execution. This can be inserted by the EVM execution client.</li>
<li><code>Gas Limit</code>: Max gas allowed in the block.</li>
<li><code>Gas Used</code>: Total gas consumed in this block.</li>
</ul>
<h4 id="transformation-to-evm-header"><a class="header" href="#transformation-to-evm-header">Transformation to EVM Header</a></h4>
<pre><code class="language-ascii">
             Rollkit Minimal Header          

                    
                     Transform

               EVM Header                    

 ParentHash           From Rollkit Header   

 Height/Number        From Rollkit Header   

 Timestamp            From Rollkit Header   

 ChainID              From Rollkit Header   

 TransactionsRoot     Derived from          
                      DataCommitment        

 StateRoot            From Rollkit Header   

 ReceiptsRoot         Added by EVM client   

 GasLimit             Added by EVM client   

 GasUsed              Added by EVM client   

 ExtraData            From Rollkit Header   

</code></pre>
<h3 id="abci-execution"><a class="header" href="#abci-execution">ABCI Execution</a></h3>
<p>This header can be transformed into an ABCI-specific header for IBC compatibility.</p>
<ul>
<li><code>Version</code>: Required by IBC clients to correctly interpret the block's structure and contents.</li>
<li><code>LastCommitHash</code>: The hash of the previous block's commit, used by IBC clients to verify the legitimacy of the block's state transitions.</li>
<li><code>DataHash</code>: A hash of the block's transaction data, enabling IBC clients to verify that the data has not been tampered with. Can be constructed from unpacking the <code>DataCommitment</code> in Rollkit header.</li>
<li><code>ValidatorHash</code>: Current validator set's hash, which IBC clients use to verify that the block was validated by the correct set of validators. This can be the IBC attester set of the chain for backward compatibility with the IBC Tendermint client, if needed.</li>
<li><code>NextValidatorsHash</code>: The hash of the next validator set, allowing IBC clients to anticipate and verify upcoming validators.</li>
<li><code>ConsensusHash</code>: Denotes the hash of the consensus parameters, ensuring that IBC clients are aligned with the consensus rules of the blockchain.</li>
<li><code>AppHash</code>: Same as the <code>StateRoot</code> in the Rollkit Header.</li>
<li><code>EvidenceHash</code>: A hash of evidence of any misbehavior by validators, which IBC clients use to assess the trustworthiness of the validator set.</li>
<li><code>LastResultsHash</code>: Root hash of all results from the transactions from the previous block.</li>
<li><code>ProposerAddress</code>: The address of the block proposer, allowing IBC clients to track and verify the entities proposing new blocks. Can be constructed from the <code>extraData</code> field in the Rollkit Header.</li>
</ul>
<h4 id="transformation-to-abci-header"><a class="header" href="#transformation-to-abci-header">Transformation to ABCI Header</a></h4>
<pre><code class="language-ascii">
             Rollkit Minimal Header          

                    
                     Transform

               ABCI Header                   

 Height               From Rollkit Header   

 Time                 From Rollkit Header   

 ChainID              From Rollkit Header   

 AppHash              From StateRoot        

 DataHash             From DataCommitment   

 Version              Added for IBC         

 LastCommitHash       Added for IBC         

 ValidatorHash        Added for IBC         

 NextValidatorsHash   Added for IBC         

 ConsensusHash        Added for IBC         

 EvidenceHash         Added for IBC         

 LastResultsHash      Added for IBC         

 ProposerAddress      From ExtraData        

</code></pre>
<h2 id="assumptions-and-considerations-4"><a class="header" href="#assumptions-and-considerations-4">Assumptions and Considerations</a></h2>
<ul>
<li>The Rollkit minimal header is designed to be flexible and adaptable, allowing for integration with various execution layers such as EVM and ABCI, without being constrained by CometBFT's header format.</li>
<li>The <code>extraData</code> field provides a mechanism for including additional metadata, such as sequencer information, which can be crucial for certain chain configurations.</li>
<li>The transformation of the Rollkit header into execution layer-specific headers should be done carefully to ensure compatibility and correctness, especially for IBC and any other cross-chain communication protocols.</li>
</ul>
<h3 id="header-transformation-flow"><a class="header" href="#header-transformation-flow">Header Transformation Flow</a></h3>
<pre><code class="language-ascii">
             Rollkit Minimal Header          
                                             
  A lightweight, flexible header format      
  with essential fields for block processing 

                             
                             
 
  EVM Header          ABCI Header        
                                         
  For EVM-based       For IBC-compatible 
  execution layers    execution layers   
 
</code></pre>
<h2 id="implementation-6"><a class="header" href="#implementation-6">Implementation</a></h2>
<p>Pending implementation.</p>
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ul>
<li><a href="https://ethereum.org/en/developers/docs/">Ethereum Developer Documentation</a>: Comprehensive resources for understanding Ethereum's architecture, including block and transaction structures.</li>
<li><a href="https://docs.tendermint.com/master/spec/">Tendermint Core Documentation</a>: Detailed documentation on Tendermint, which includes information on ABCI and its header format.</li>
<li><a href="https://github.com/tendermint/spec/blob/master/spec/abci/abci.md">ABCI Specification</a>: The official specification for the Application Blockchain Interface (ABCI), which describes how applications can interact with the Tendermint consensus engine.</li>
<li><a href="https://github.com/cosmos/ibc">IBC Protocol Specification</a>: Documentation on the Inter-Blockchain Communication (IBC) protocol, which includes details on how headers are used for cross-chain communication.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="p2p-1"><a class="header" href="#p2p-1">P2P</a></h1>
<p>Every  node (both full and light) runs a P2P client using <a href="https://github.com/libp2p/go-libp2p">go-libp2p</a> P2P networking stack for gossiping transactions in the chain's P2P network. The same P2P client is also used by the header and block sync services for gossiping headers and blocks.</p>
<p>Following parameters are required for creating a new instance of a P2P client:</p>
<ul>
<li>P2PConfig (described below)</li>
<li><a href="https://github.com/libp2p/go-libp2p">go-libp2p</a> private key used to create a libp2p connection and join the p2p network.</li>
<li>chainID: identifier used as namespace within the p2p network for peer discovery. The namespace acts as a sub network in the p2p network, where peer connections are limited to the same namespace.</li>
<li>datastore: an instance of <a href="https://github.com/ipfs/go-datastore">go-datastore</a> used for creating a connection gator and stores blocked and allowed peers.</li>
<li>logger</li>
</ul>
<pre><code class="language-go">// P2PConfig stores configuration related to peer-to-peer networking.
type P2PConfig struct {
	ListenAddress string // Address to listen for incoming connections
	Seeds         string // Comma separated list of seed nodes to connect to
	BlockedPeers  string // Comma separated list of nodes to ignore
	AllowedPeers  string // Comma separated list of nodes to whitelist
}
</code></pre>
<p>A P2P client also instantiates a <a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/net/conngater">connection gator</a> to block and allow peers specified in the <code>P2PConfig</code>.</p>
<p>It also sets up a gossiper using the gossip topic <code>&lt;chainID&gt;+&lt;txTopicSuffix&gt;</code> (<code>txTopicSuffix</code> is defined in <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">p2p/client.go</a>), a Distributed Hash Table (DHT) using the <code>Seeds</code> defined in the <code>P2PConfig</code> and peer discovery using go-libp2p's <code>discovery.RoutingDiscovery</code>.</p>
<p>A P2P client provides an interface <code>SetTxValidator(p2p.GossipValidator)</code> for specifying a gossip validator which can define how to handle the incoming <code>GossipMessage</code> in the P2P network. The <code>GossipMessage</code> represents message gossiped via P2P network (e.g. transaction, Block etc).</p>
<pre><code class="language-go">// GossipValidator is a callback function type.
type GossipValidator func(*GossipMessage) bool
</code></pre>
<p>The full nodes define a transaction validator (shown below) as gossip validator for processing the gossiped transactions to add to the mempool, whereas light nodes simply pass a dummy validator as light nodes do not process gossiped transactions.</p>
<pre><code class="language-go">// newTxValidator creates a pubsub validator that uses the node's mempool to check the
// transaction. If the transaction is valid, then it is added to the mempool
func (n *FullNode) newTxValidator() p2p.GossipValidator {
</code></pre>
<pre><code class="language-go">// Dummy validator that always returns a callback function with boolean `false`
func (ln *LightNode) falseValidator() p2p.GossipValidator {
</code></pre>
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/p2p/client.go">client.go</a></p>
<p>[2] <a href="https://github.com/ipfs/go-datastore">go-datastore</a></p>
<p>[3] <a href="https://github.com/libp2p/go-libp2p">go-libp2p</a></p>
<p>[4] <a href="https://github.com/libp2p/go-libp2p/tree/master/p2p/net/conngater">conngater</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-1"><a class="header" href="#store-1">Store</a></h1>
<h2 id="abstract-7"><a class="header" href="#abstract-7">Abstract</a></h2>
<p>The Store interface defines methods for storing and retrieving blocks, commits, and the state of the blockchain.</p>
<h2 id="protocolcomponent-description-4"><a class="header" href="#protocolcomponent-description-4">Protocol/Component Description</a></h2>
<p>The Store interface defines the following methods:</p>
<ul>
<li><code>Height</code>: Returns the height of the highest block in the store.</li>
<li><code>SetHeight</code>: Sets given height in the store if it's higher than the existing height in the store.</li>
<li><code>SaveBlock</code>: Saves a block along with its seen signature.</li>
<li><code>GetBlock</code>: Returns a block at a given height.</li>
<li><code>GetBlockByHash</code>: Returns a block with a given block header hash.</li>
<li><code>SaveBlockResponses</code>: Saves block responses in the Store.</li>
<li><code>GetBlockResponses</code>: Returns block results at a given height.</li>
<li><code>GetSignature</code>: Returns a signature for a block at a given height.</li>
<li><code>GetSignatureByHash</code>: Returns a signature for a block with a given block header hash.</li>
<li><code>UpdateState</code>: Updates the state saved in the Store. Only one State is stored.</li>
<li><code>GetState</code>: Returns the last state saved with UpdateState.</li>
<li><code>SaveValidators</code>: Saves the validator set at a given height.</li>
<li><code>GetValidators</code>: Returns the validator set at a given height.</li>
</ul>
<p>The <code>TxnDatastore</code> interface inside <a href="https://github.com/ipfs/go-datastore">go-datastore</a> is used for constructing different key-value stores for the underlying storage of a full node. The are two different implementations of <code>TxnDatastore</code> in <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/kv.go">kv.go</a>:</p>
<ul>
<li>
<p><code>NewDefaultInMemoryKVStore</code>: Builds a key-value store that uses the <a href="https://github.com/dgraph-io/badger">BadgerDB</a> library and operates in-memory, without accessing the disk. Used only across unit tests and integration tests.</p>
</li>
<li>
<p><code>NewDefaultKVStore</code>: Builds a key-value store that uses the <a href="https://github.com/dgraph-io/badger">BadgerDB</a> library and stores the data on disk at the specified path.</p>
</li>
</ul>
<p>A Rollkit full node is <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L96">initialized</a> using <code>NewDefaultKVStore</code> as the base key-value store for underlying storage. To store various types of data in this base key-value store, different prefixes are used: <code>mainPrefix</code>, <code>dalcPrefix</code>, and <code>indexerPrefix</code>. The <code>mainPrefix</code> equal to <code>0</code> is used for the main node data, <code>dalcPrefix</code> equal to <code>1</code> is used for Data Availability Layer Client (DALC) data, and <code>indexerPrefix</code> equal to <code>2</code> is used for indexing related data.</p>
<p>For the main node data, <code>DefaultStore</code> struct, an implementation of the Store interface, is used with the following prefixes for various types of data within it:</p>
<ul>
<li><code>blockPrefix</code> with value &quot;b&quot;: Used to store blocks in the key-value store.</li>
<li><code>indexPrefix</code> with value &quot;i&quot;: Used to index the blocks stored in the key-value store.</li>
<li><code>commitPrefix</code> with value &quot;c&quot;: Used to store commits related to the blocks.</li>
<li><code>statePrefix</code> with value &quot;s&quot;: Used to store the state of the blockchain.</li>
<li><code>responsesPrefix</code> with value &quot;r&quot;: Used to store responses related to the blocks.</li>
<li><code>validatorsPrefix</code> with value &quot;v&quot;: Used to store validator sets at a given height.</li>
</ul>
<p>For example, in a call to <code>GetBlockByHash</code> for some block hash <code>&lt;block_hash&gt;</code>, the key used in the full node's base key-value store will be <code>/0/b/&lt;block_hash&gt;</code> where <code>0</code> is the main store prefix and <code>b</code> is the block prefix. Similarly, in a call to <code>GetValidators</code> for some height <code>&lt;height&gt;</code>, the key used in the full node's base key-value store will be <code>/0/v/&lt;height&gt;</code> where <code>0</code> is the main store prefix and <code>v</code> is the validator set prefix.</p>
<p>Inside the key-value store, the value of these various types of data like <code>Block</code> is stored as a byte array which is encoded and decoded using the corresponding Protobuf <a href="https://github.com/rollkit/rollkit/blob/main/types/serialization.go">marshal and unmarshal methods</a>.</p>
<p>The store is most widely used inside the <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">block manager</a> to perform their functions correctly. Within the block manager, since it has multiple go-routines in it, it is protected by a mutex lock, <code>lastStateMtx</code>, to synchronize read/write access to it and prevent race conditions.</p>
<h2 id="message-structurecommunication-format-5"><a class="header" href="#message-structurecommunication-format-5">Message Structure/Communication Format</a></h2>
<p>The Store does not communicate over the network, so there is no message structure or communication format.</p>
<h2 id="assumptions-and-considerations-5"><a class="header" href="#assumptions-and-considerations-5">Assumptions and Considerations</a></h2>
<p>The Store assumes that the underlying datastore is reliable and provides atomicity for transactions. It also assumes that the data passed to it for storage is valid and correctly formatted.</p>
<h2 id="implementation-7"><a class="header" href="#implementation-7">Implementation</a></h2>
<p>See <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go#L11">Store Interface</a> and <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Default Store</a> for its implementation.</p>
<h2 id="references-8"><a class="header" href="#references-8">References</a></h2>
<p>[1] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/types.go#L11">Store Interface</a></p>
<p>[2] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/store.go">Default Store</a></p>
<p>[3] <a href="https://github.com/rollkit/rollkit/blob/main/node/full.go#L96">Full Node Store Initialization</a></p>
<p>[4] <a href="https://github.com/rollkit/rollkit/blob/main/block/manager.go">Block Manager</a></p>
<p>[5] <a href="https://github.com/dgraph-io/badger">Badger DB</a></p>
<p>[6] <a href="https://github.com/ipfs/go-datastore">Go Datastore</a></p>
<p>[7] <a href="https://github.com/rollkit/rollkit/blob/main/pkg/store/kv.go">Key Value Store</a></p>
<p>[8 ] <a href="https://github.com/rollkit/rollkit/blob/main/types/serialization.go">Serialization</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
